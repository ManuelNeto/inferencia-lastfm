---
title: "Implementando ICs"
author: "Nazareno"
output:
  html_document:
    theme: readable
    df_print: paged
    toc: yes
  html_notebook:
    fig_width: 7
    theme: readable
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(boot)
theme_set(theme_bw())
```

## Os dados

```{r}
set.seed(12345)

lastfm = read_csv(here::here("data/experimento-lastfm.csv"), 
                  col_types = cols(.default = col_double(), 
                                   user = col_character()))

lastfm = lastfm %>% 
  sample_n(300) %>% 
  select(news, old, mediana_pop)

glimpse(lastfm)
```

## Proporção de artistas novos e popularidade

Utilizaremos ICs para estimar duas métricas sobre os usuários do LastFM em geral durante um período de 6 meses. Em ambos os casos faremos isso a partir de uma amostra de 300 usuários. As duas métricas são: 

1. Qual a proporção de novos artistas em geral escutada por usuários?
2. Para os usuários que gostam de música muito pop (mediana_pop > 5), qual a correlação entre a popularidade mediana dos artistas escutado e a proporção dos artistas escutados que eram novos. 

Crie intervalos com 95% de confiança.


# Questão 1

```{r}
### Questão 1

lastfm = lastfm %>%
   mutate(proporcao = (news / (news + old)) * 100) 



funcao_theta_proporcao = function(df) {
  df %>%
    pull(proporcao) %>%
    mean()
}

theta_c_proporcao = funcao_theta_proporcao(lastfm)

```




```{r}
### Questão 1
repeticoes = 4000 # pelo menos 2000, mas mais não faz mal.

um_bootstrap_proporcao <- function(df){
  boot_x <- sample_n(df,           # amostre dos dados
                   size = NROW(news), # tamanho igual ao recebido
                   replace = TRUE) # aqui é o bootstrap
  return(funcao_theta_proporcao(boot_x))
}

set.seed(1212)

# A REAMOSTRAGEM PARA PROPORCAO
reamostragens_proporcao = tibble(i = 1:repeticoes) %>% 
  mutate(theta_c_s_proporcao = map(i, ~ um_bootstrap_proporcao(lastfm))) %>% 
  unnest(theta_c_s_proporcao)

reamostragens_proporcao

reamostragens_proporcao %>%
  ggplot(aes(x = theta_c_s_proporcao)) +
  geom_histogram(binwidth = .5,
                 colour = "darkorange",
                 fill = "white")

reamostragens_proporcao %>%
  ggplot(aes(x = theta_c_s_proporcao - theta_c_proporcao)) +
  geom_histogram(binwidth = 1,
                 colour = "darkblue",
                 fill = "white")

```

Se é retirado os erros amostrais

```{r}
intervalo = reamostragens_proporcao %>% 
  mutate(error = theta_c_s_proporcao - theta_c_proporcao) %>% 
  summarise(inf_error = quantile(error, .025), 
            sup_error = quantile(error, .975))
intervalo
```

E a seguir é calculado o intervalo de confiança: [inf_value, sup_value]

```{r}
intervalo = intervalo %>% 
  mutate(inf_value = theta_c_proporcao + inf_error, 
         sup_value = theta_c_proporcao + sup_error)
intervalo
```

Abaixo é realizado o bootstrap usando a biblioteca 'boot'.

```{r}
set.seed(1)
funcao_theta_proporcao = function(df, i) {
    df %>%
        slice(i) %>%
        pull(proporcao) %>%
        mean()
}
booted <- boot(data = lastfm,
               statistic = funcao_theta_proporcao,
               R = 4000)
intervalo_calc <- boot.ci(booted, conf=.95, type="bca")
intervalo_calc
```

```{r}

ggplot() +
  geom_rect(
    data = intervalo,
    aes(xmin = inf_value, xmax = sup_value),
    ymin = -Inf,
    ymax = Inf,
    fill = "gold",
    alpha = .25
  ) +
  geom_histogram(
    data = reamostragens_proporcao,
    aes(theta_c_s_proporcao),
    binwidth = .5,
    fill = "white",
    colour = "darkgrey"
  ) +
  geom_vline(xintercept = theta_c_proporcao, color = "dark green") +
  labs(title = expression("Intervalo estimado via bootstrap"))

```












```{r}
### Questão 1
repeticoes = 4000 # pelo menos 2000, mas mais não faz mal.

um_bootstrap_proporcao <- function(df){
  boot_x <- sample_n(df,           # amostre dos dados
                   size = NROW(news), # tamanho igual ao recebido
                   replace = TRUE) # aqui é o bootstrap
  return(funcao_theta_proporcao(boot_x))
}

set.seed(1212)

# A REAMOSTRAGEM PARA PROPORCAO
reamostragens_proporcao = tibble(i = 1:repeticoes) %>% 
  mutate(theta_c_s = map(i, ~ um_bootstrap_proporcao(lastfm))) %>% 
  unnest(theta_c_s)

reamostragens_proporcao

### Questão 2

um_bootstrap_correlacao <- function(df){
  boot_x <- sample_n(df,           # amostre dos dados
                   size = NROW(news), # tamanho igual ao recebido
                   replace = TRUE) # aqui é o bootstrap
  return(funcao_theta_correlacao(boot_x))
}

set.seed(1212)

# A REAMOSTRAGEM CORRELACAO
reamostragens_correlacao = tibble(i = 1:repeticoes) %>% 
  mutate(theta_c_s = map(i, ~ um_bootstrap_correlacao(lastfm))) %>% 
  unnest(theta_c_s)

reamostragens_correlacao

reamostragens_correlacao %>%
  ggplot(aes(x = theta_c_s)) +
  geom_histogram(binwidth = .5,
                 colour = "darkorange",
                 fill = "white")

reamostragens_correlacao %>%
  ggplot(aes(x = theta_c_s - theta_c)) +
  geom_histogram(binwidth = 1,
                 colour = "darkblue",
                 fill = "white")

```

```{r}

```



